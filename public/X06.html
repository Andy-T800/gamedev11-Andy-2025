<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini Doom+ Enhanced</title>
<style>
  body { 
    margin: 0; 
    overflow: hidden; 
    background: #000; 
    /* Custom font for HUD */
    font-family: 'Press Start 2P', cursive;
    /* Link a pixel font (needs internet connection) */
    /* @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap'); */
  }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
// --- Canvas Setup ---
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// --- Settings and Constants ---
const TILE_SIZE = 64;
const FOV = Math.PI / 3;
const NUM_RAYS = canvas.width;
const MAX_DEPTH = 1000; // Increased depth for better visibility
const MAP_WIDTH = 16;
const MAP_HEIGHT = 11;
const ENEMY_HP = 50;
const PLAYER_MAX_HP = 100;
const SHOOT_COOLDOWN_MAX = 10;
let shootCooldown = 0; // New: prevents spamming fire

// --- Map (Added different wall types) ---
const map = [
    "################",
    "#1.............#",
    "#..###...2.....#",
    "#......##......#",
    "#...2..........#",
    "#......#.......#",
    "#..............#",
    "###...........1#",
    "#......###.....#",
    "#.....2........#",
    "################"
];

// --- Player ---
let player = {
    x: 160,
    y: 160,
    angle: 0,
    speed: 0,
    strafe: 0,
    hp: PLAYER_MAX_HP,
    bob: 0,
    score: 0 // New: score tracking
};

// --- Game Objects ---
let bullets = [];
let enemies = [];
let healthPacks = [];
let gameOver = false;

// --- Controls ---
const keys = {};
document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
document.addEventListener("click", () => shoot());

// --- Mouse Look & Pointer Lock ---
document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
document.addEventListener("click", () => { 
    if (!gameOver) document.body.requestPointerLock(); 
});
document.addEventListener("mousemove", e => {
    if (document.pointerLockElement === document.body && !gameOver) {
        player.angle += e.movementX * 0.002;
    }
});

// --- Audio (Updated to use shorter, lower latency sounds) ---
const shootSound = new Audio("https://actions.google.com/sounds/v1/weapons/laser_gun_fire_01.ogg");
const hitSound = new Audio("https://actions.google.com/sounds/v1/impacts/punch_short.ogg");
const damageSound = new Audio("https://actions.google.com/sounds/v1/cartoon/clown_honk.ogg"); // Added damage sound
const pickupSound = new Audio("https://actions.google.com/sounds/v1/games/coin_bag.ogg");
shootSound.volume = 0.5;
hitSound.volume = 0.8;
damageSound.volume = 0.8;

// --- Utility Functions ---
function isWall(x, y) {
    const mx = Math.floor(x / TILE_SIZE);
    const my = Math.floor(y / TILE_SIZE);
    if (my < 0 || my >= MAP_HEIGHT || mx < 0 || mx >= MAP_WIDTH) return true;
    const tile = map[my][mx];
    return tile === "#" || tile === "1" || tile === "2";
}

function getWallType(x, y) {
    const mx = Math.floor(x / TILE_SIZE);
    const my = Math.floor(y / TILE_SIZE);
    if (my < 0 || my >= MAP_HEIGHT || mx < 0 || mx >= MAP_WIDTH) return "#";
    return map[my][mx];
}

function shoot() {
    if (gameOver || shootCooldown > 0) return;
    shootSound.currentTime = 0;
    shootSound.play();
    shootCooldown = SHOOT_COOLDOWN_MAX; // Set cooldown
    bullets.push({
        x: player.x,
        y: player.y,
        angle: player.angle,
        alive: true,
        flash: 5 // Muzzle flash duration
    });
}

function spawnEnemy() {
    if (gameOver) return;
    const spawnPoints = [
        { x: 800, y: 600 },
        { x: 600, y: 400 },
        { x: 1000, y: 500 },
        { x: 700, y: 700 },
        { x: 200, y: 600 } // Added a new spawn point
    ];
    const pick = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
    enemies.push({
        x: pick.x,
        y: pick.y,
        alive: true,
        hp: ENEMY_HP,
        damageCooldown: 0,
        type: Math.random() < 0.2 ? 'fast' : 'normal', // New: different enemy types
        color: Math.random() < 0.2 ? 'blue' : 'red'
    });
}
setInterval(spawnEnemy, 5000); // Faster enemy spawn
spawnEnemy();

function spawnHealthPack() {
    if (gameOver) return;
    const spawnPoints = [
        { x: 400, y: 500 },
        { x: 700, y: 300 },
        { x: 900, y: 600 },
        { x: 120, y: 120 } // Added a new spawn point
    ];
    const pick = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
    healthPacks.push(pick);
}
setInterval(spawnHealthPack, 15000); // Slightly slower health pack spawn

// --- Game Loop: Update ---
function update() {
    if (gameOver) return;
    
    // Player movement
    const moveSpeed = 3.0; // Slightly faster movement
    const rot = player.angle;
    const dx = Math.cos(rot);
    const dy = Math.sin(rot);
    player.speed = (keys["w"] ? moveSpeed : 0) - (keys["s"] ? moveSpeed * 0.7 : 0); // Slower backward
    player.strafe = (keys["a"] ? -moveSpeed * 0.8 : 0) + (keys["d"] ? moveSpeed * 0.8 : 0); // Slower strafe

    const nx = player.x + (dx * player.speed + Math.cos(rot + Math.PI/2) * player.strafe);
    const ny = player.y + (dy * player.speed + Math.sin(rot + Math.PI/2) * player.strafe);
    // Added boundary check to prevent clipping through walls
    if (!isWall(nx + dx * 10, ny + dy * 10)) { 
        player.x = nx;
        player.y = ny;
    }
    
    // Player bobbing proportional to speed
    if (player.speed !== 0 || player.strafe !== 0) {
        player.bob = (player.bob + Math.abs(player.speed) * 0.1 + Math.abs(player.strafe) * 0.1) % (2 * Math.PI);
    } else {
        player.bob *= 0.9; // Decays bob when still
    }

    // Cooldowns
    if (shootCooldown > 0) shootCooldown--;

    // Bullets
    bullets.forEach(b => {
        if (!b.alive) return;
        b.x += Math.cos(b.angle) * 15; // Faster bullets
        b.y += Math.sin(b.angle) * 15;
        if (isWall(b.x, b.y)) b.alive = false;
        if (b.flash > 0) b.flash--;
    });

    // Enemies
    enemies.forEach(e => {
        if (!e.alive) return;
        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const dist = Math.hypot(dx, dy);
        const enemySpeed = e.type === 'fast' ? 1.8 : 1.0;
        
        if (dist > 5) {
            e.x += (dx / dist) * enemySpeed;
            e.y += (dy / dist) * enemySpeed;
        }

        if (dist < 35 && e.damageCooldown <= 0) { // Increased attack range slightly
            player.hp -= 10;
            e.damageCooldown = 60; // Longer enemy attack cooldown
            damageSound.currentTime = 0;
            damageSound.play();
            if (player.hp <= 0) gameOver = true;
        }
        if (e.damageCooldown > 0) e.damageCooldown--;
    });

    // Bullet vs Enemy
    bullets.forEach(b => {
        enemies.forEach(e => {
            if (!b.alive || !e.alive) return;
            const dx = b.x - e.x;
            const dy = b.y - e.y;
            if (Math.hypot(dx, dy) < 25) { // Increased hit area
                b.alive = false;
                e.hp -= 25; // Lower bullet damage, requires more shots
                hitSound.currentTime = 0;
                hitSound.play();
                if (e.hp <= 0) {
                    e.alive = false;
                    player.score += (e.type === 'fast' ? 200 : 100); // Score depends on enemy type
                }
            }
        });
    });

    // Health packs
    healthPacks = healthPacks.filter(p => {
        const dx = p.x - player.x;
        const dy = p.y - player.y;
        if (Math.hypot(dx, dy) < 40) { // Larger pickup radius
            pickupSound.currentTime = 0;
            pickupSound.play();
            player.hp = Math.min(PLAYER_MAX_HP, player.hp + 30);
            return false;
        }
        return true;
    });

    bullets = bullets.filter(b => b.alive);
}

// --- Raycasting and Rendering ---
function castRay(rayAngle) {
    const cos = Math.cos(rayAngle);
    const sin = Math.sin(rayAngle);
    let lastWallType = '#';

    for (let depth = 0; depth < MAX_DEPTH; depth += 4) { // Larger step for faster cast
        const tx = player.x + cos * depth;
        const ty = player.y + sin * depth;
        if (isWall(tx, ty)) {
             // Find more precise hit point for texturing/shading
             for (let d = depth - 4; d < depth; d += 0.5) {
                 if (isWall(player.x + cos * d, player.y + sin * d)) {
                     lastWallType = getWallType(player.x + cos * d, player.y + sin * d);
                     return { depth: d, type: lastWallType };
                 }
             }
             return { depth: depth, type: getWallType(tx, ty) };
        }
    }
    return { depth: MAX_DEPTH, type: '#' };
}

function getWallColor(type, shade) {
    if (type === '1') return `rgb(${shade},${shade/2},${shade/2})`; // Reddish Wall
    if (type === '2') return `rgb(${shade/2},${shade/2},${shade})`; // Bluish Wall
    return `rgb(${shade / 2},${shade / 2},${shade})`; // Default (Blueish)
}

function render3DView() {
    // Floor and Ceiling
    ctx.fillStyle = "#333"; // Ceiling (Dark Grey)
    ctx.fillRect(0, 0, canvas.width, canvas.height / 2);
    ctx.fillStyle = "#444"; // Floor (Slightly Lighter Dark Grey)
    ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);

    const zBuffer = [];
    for (let i = 0; i < NUM_RAYS; i++) {
        const rayAngle = player.angle - FOV / 2 + (i / NUM_RAYS) * FOV;
        const hit = castRay(rayAngle);
        const corrected = hit.depth * Math.cos(rayAngle - player.angle);
        zBuffer[i] = corrected;

        const height = (TILE_SIZE * 800) / (corrected || 1);
        const maxShade = 200; // Increased ambient light
        const shade = maxShade - Math.min(maxShade, corrected * 0.2); 
        ctx.fillStyle = getWallColor(hit.type, shade);
        ctx.fillRect(i, canvas.height / 2 - height / 2, 1, height);
    }

    // Draw Sprites (Enemies and Health Packs) - Sorted by distance for correct drawing order
    const sprites = [
        ...enemies.filter(e => e.alive).map(e => ({...e, isEnemy: true})),
        ...healthPacks.map(p => ({...p, isHealth: true}))
    ];

    sprites.sort((a, b) => {
        const distA = Math.hypot(a.x - player.x, a.y - player.y);
        const distB = Math.hypot(b.x - player.x, b.y - player.y);
        return distB - distA; // Draw farthest first
    });

    sprites.forEach(sprite => {
        const dx = sprite.x - player.x;
        const dy = sprite.y - player.y;
        const distance = Math.hypot(dx, dy);
        
        // Skip if too far
        if (distance > MAX_DEPTH) return;
        
        let angleToItem = Math.atan2(dy, dx) - player.angle;
        // Normalize angle to be between -PI and PI for FOV check
        if (angleToItem > Math.PI) angleToItem -= 2 * Math.PI;
        if (angleToItem < -Math.PI) angleToItem += 2 * Math.PI;

        if (Math.abs(angleToItem) > FOV / 2 + 0.1) return; // Add a small buffer

        const correctedDist = distance * Math.cos(angleToItem);
        const size = (TILE_SIZE * (sprite.isEnemy ? 800 : 600)) / correctedDist;
        const screenX = Math.tan(angleToItem) * canvas.width / (2 * Math.tan(FOV / 2));
        const screenPos = canvas.width / 2 + screenX;
        const startX = Math.floor(screenPos - size / 2);
        const endX = Math.floor(screenPos + size / 2);
        
        // Draw the sprite
        for (let x = startX; x < endX; x++) {
            if (x >= 0 && x < canvas.width && zBuffer[x] > correctedDist) {
                if (sprite.isEnemy) {
                    const r = 255 * (sprite.hp / ENEMY_HP);
                    ctx.fillStyle = sprite.color === 'blue' ? `rgb(0,0,${200 * (sprite.hp / ENEMY_HP)})` : `rgb(${r},0,0)`;
                    ctx.fillRect(x, canvas.height / 2 - size / 2, 1, size);
                } else if (sprite.isHealth) {
                    ctx.fillStyle = "lime";
                    ctx.fillRect(x, canvas.height / 2 - size / 2, 1, size);
                }
            }
        }
    });
}

function renderHUD() {
    ctx.textAlign = "left";
    ctx.font = "20px monospace";
    
    // HP Bar
    ctx.fillStyle = "black";
    ctx.fillRect(20, 20, 200, 30);
    const hpColor = player.hp > 50 ? "lime" : (player.hp > 25 ? "yellow" : "red");
    ctx.fillStyle = hpColor;
    ctx.fillRect(20, 20, 200 * (player.hp / PLAYER_MAX_HP), 30);
    ctx.strokeStyle = "white";
    ctx.strokeRect(20, 20, 200, 30);

    ctx.fillStyle = "white";
    ctx.fillText(`HP: ${player.hp}`, 20, 70);
    ctx.fillText(`SCORE: ${player.score}`, 20, 100);

    // Crosshair
    const crosshairSize = 15;
    ctx.strokeStyle = shootCooldown > 0 ? "red" : "white"; // Red crosshair when on cooldown
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(canvas.width/2 - crosshairSize, canvas.height/2);
    ctx.lineTo(canvas.width/2 - 5, canvas.height/2);
    ctx.moveTo(canvas.width/2 + 5, canvas.height/2);
    ctx.lineTo(canvas.width/2 + crosshairSize, canvas.height/2);

    ctx.moveTo(canvas.width/2, canvas.height/2 - crosshairSize);
    ctx.lineTo(canvas.width/2, canvas.height/2 - 5);
    ctx.moveTo(canvas.width/2, canvas.height/2 + 5);
    ctx.lineTo(canvas.width/2, canvas.height/2 + crosshairSize);
    ctx.stroke();
    ctx.lineWidth = 1;
}

function renderGun() {
    const w = 150; // Wider gun
    const h = 100; // Taller gun
    const bobOffset = Math.sin(player.bob) * 10; // Increased bob amount
    const flashOffset = bullets.length && bullets[bullets.length-1].flash > 0 ? -10 : 0; // Gun kickback
    
    const x = canvas.width / 2 - w / 2;
    const y = canvas.height - h - 10 + bobOffset + flashOffset;
    
    // Gun body
    ctx.fillStyle = "#666";
    ctx.fillRect(x, y, w, h);
    
    // Gun barrel
    ctx.fillStyle = "#333";
    ctx.fillRect(x + w * 0.1, y + h * 0.1, w * 0.8, h * 0.2);

    // Muzzle flash
    if (bullets.length && bullets[bullets.length-1].flash > 0) {
        ctx.fillStyle = "yellow";
        ctx.globalAlpha = bullets[bullets.length-1].flash / 5; // Fades out the flash
        ctx.fillRect(x + w - 20, y + 5, 20, 20);
        ctx.globalAlpha = 1;
    }
}

function renderGameOver() {
    ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "red";
    ctx.textAlign = "center";
    ctx.font = "60px sans-serif";
    ctx.fillText("YOU DIED", canvas.width / 2, canvas.height / 2 - 40);
    ctx.font = "30px sans-serif";
    ctx.fillStyle = "white";
    ctx.fillText(`Final Score: ${player.score}`, canvas.width / 2, canvas.height / 2 + 30);
    ctx.font = "15px sans-serif";
    ctx.fillText("Click to restart", canvas.width / 2, canvas.height / 2 + 80);
    
    // Simple restart mechanism
    document.addEventListener("click", () => window.location.reload(), { once: true });
}

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    render3DView();
    renderGun();
    renderHUD();

    if (player.hp <= 0) {
        gameOver = true;
        renderGameOver();
    }
}

// --- Main Loop ---
function loop() {
    update();
    render();
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
</html>
