<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini Doom+ Enhanced</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #000;
    font-family: 'Press Start 2P', cursive;
  }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
/* ============================================================
   MINI DOOM+ ENHANCED (CLEANED VERSION)
   ============================================================ */

// --- Canvas Setup ---
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const resizeCanvas = () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
};
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// --- Constants ---
const TILE = 64, FOV = Math.PI / 3;
const MAX_DEPTH = 1000, ENEMY_HP = 50;
const PLAYER_HP = 100, SHOOT_COOLDOWN = 10;
const MAP_WIDTH = 16, MAP_HEIGHT = 11;
const NUM_RAYS = Math.floor(canvas.width / 2);
let shootTimer = 0;

// --- Map Data ---
const map = [
  "################",
  "#1.............#",
  "#..###...2.....#",
  "#......##......#",
  "#...2..........#",
  "#......#.......#",
  "#..............#",
  "###...........1#",
  "#......###.....#",
  "#.....2........#",
  "################"
];

// --- Game State ---
const player = { x: 160, y: 160, angle: 0, hp: PLAYER_HP, score: 0, bob: 0 };
let bullets = [], enemies = [], packs = [];
let gameOver = false;

// --- Input ---
const keys = {};
document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

// --- Pointer Lock & Shooting ---
document.addEventListener("click", () => {
  if (gameOver) { location.reload(); return; }
  document.body.requestPointerLock?.();
  shoot();
});
document.addEventListener("mousemove", e => {
  if (document.pointerLockElement === document.body && !gameOver)
    player.angle += e.movementX * 0.002;
});

// --- Audio ---
const loadSound = src => { const a = new Audio(src); a.volume = 0.6; return a; };
const sfx = {
  shoot: loadSound("https://actions.google.com/sounds/v1/weapons/laser_gun_fire_01.ogg"),
  hit: loadSound("https://actions.google.com/sounds/v1/impacts/punch_short.ogg"),
  hurt: loadSound("https://actions.google.com/sounds/v1/cartoon/clown_honk.ogg"),
  pickup: loadSound("https://actions.google.com/sounds/v1/games/coin_bag.ogg")
};

// --- Utilities ---
const isWall = (x, y) => {
  const mx = Math.floor(x / TILE), my = Math.floor(y / TILE);
  if (my < 0 || my >= MAP_HEIGHT || mx < 0 || mx >= MAP_WIDTH) return true;
  return "#12".includes(map[my][mx]);
};
const wallType = (x, y) => map[Math.floor(y / TILE)]?.[Math.floor(x / TILE)] || "#";
const rand = arr => arr[Math.floor(Math.random() * arr.length)];

// --- Shooting ---
function shoot() {
  if (shootTimer > 0 || gameOver) return;
  sfx.shoot.currentTime = 0; sfx.shoot.play();
  bullets.push({ x: player.x, y: player.y, angle: player.angle, life: 30, flash: 5 });
  shootTimer = SHOOT_COOLDOWN;
}

// --- Spawning ---
const spawnEnemy = () => {
  if (gameOver) return;
  const p = rand([{x:800,y:600},{x:600,y:400},{x:1000,y:500},{x:700,y:700},{x:200,y:600}]);
  enemies.push({ ...p, hp: ENEMY_HP, alive: true, cd: 0, fast: Math.random() < 0.2 });
};
const spawnPack = () => {
  if (gameOver) return;
  packs.push(rand([{x:400,y:500},{x:700,y:300},{x:900,y:600},{x:120,y:120}]));
};
setInterval(spawnEnemy, 5000);
setInterval(spawnPack, 15000);
spawnEnemy();

// --- Update Loop ---
function update() {
  if (gameOver) return;
  const spd = 3, rot = player.angle;
  const dx = Math.cos(rot), dy = Math.sin(rot);
  const move = (keys["w"] ? spd : 0) - (keys["s"] ? spd * 0.7 : 0);
  const strafe = (keys["a"] ? -spd * 0.8 : 0) + (keys["d"] ? spd * 0.8 : 0);
  const nx = player.x + dx * move + Math.cos(rot + Math.PI/2) * strafe;
  const ny = player.y + dy * move + Math.sin(rot + Math.PI/2) * strafe;
  if (!isWall(nx, ny)) { player.x = nx; player.y = ny; }

  player.bob += Math.abs(move) * 0.1 + Math.abs(strafe) * 0.1;
  if (shootTimer > 0) shootTimer--;

  // Bullets
  for (const b of bullets) {
    b.x += Math.cos(b.angle) * 15;
    b.y += Math.sin(b.angle) * 15;
    if (isWall(b.x, b.y) || --b.life <= 0) b.dead = true;
    if (b.flash > 0) b.flash--;
  }
  bullets = bullets.filter(b => !b.dead);

  // Enemies
  for (const e of enemies) {
    if (!e.alive) continue;
    const dx = player.x - e.x, dy = player.y - e.y, d = Math.hypot(dx, dy);
    const speed = e.fast ? 1.8 : 1.0;
    if (d > 5) { e.x += (dx / d) * speed; e.y += (dy / d) * speed; }
    if (d < 35 && e.cd <= 0) {
      player.hp -= 10; e.cd = 60; sfx.hurt.currentTime = 0; sfx.hurt.play();
      if (player.hp <= 0) gameOver = true;
    }
    if (e.cd > 0) e.cd--;
  }

  // Bullet hits
  for (const b of bullets) for (const e of enemies) {
    if (!e.alive || b.dead) continue;
    if (Math.hypot(b.x - e.x, b.y - e.y) < 25) {
      e.hp -= 25; b.dead = true;
      sfx.hit.currentTime = 0; sfx.hit.play();
      if (e.hp <= 0) {
        e.alive = false;
        player.score += e.fast ? 200 : 100;
      }
    }
  }

  // Health packs
  packs = packs.filter(p => {
    if (Math.hypot(p.x - player.x, p.y - player.y) < 40) {
      sfx.pickup.currentTime = 0; sfx.pickup.play();
      player.hp = Math.min(PLAYER_HP, player.hp + 30);
      return false;
    }
    return true;
  });
}

// --- Rendering ---
function castRay(rayAngle) {
  const cos = Math.cos(rayAngle), sin = Math.sin(rayAngle);
  for (let d = 0; d < MAX_DEPTH; d += 4) {
    const x = player.x + cos * d, y = player.y + sin * d;
    if (isWall(x, y)) return { depth: d, type: wallType(x, y) };
  }
  return { depth: MAX_DEPTH, type: "#" };
}

function render3D() {
  const mid = canvas.height / 2;
  ctx.fillStyle = "#222"; ctx.fillRect(0, 0, canvas.width, mid);
  ctx.fillStyle = "#444"; ctx.fillRect(0, mid, canvas.width, mid);
  const z = [];

  for (let i = 0; i < NUM_RAYS; i++) {
    const rayAngle = player.angle - FOV/2 + i/NUM_RAYS*FOV;
    const hit = castRay(rayAngle);
    const dist = hit.depth * Math.cos(rayAngle - player.angle);
    z[i] = dist;
    const h = (TILE * 800) / dist;
    const shade = 200 - Math.min(200, dist * 0.2);
    const c = hit.type === "1" ? `rgb(${shade},${shade/2},${shade/2})` :
              hit.type === "2" ? `rgb(${shade/2},${shade/2},${shade})` :
                                 `rgb(${shade/2},${shade/2},${shade})`;
    ctx.fillStyle = c;
    ctx.fillRect(i*2, mid - h/2, 2, h);
  }

  // Sprites
  const all = [
    ...enemies.filter(e=>e.alive).map(e=>({...e, enemy:true})),
    ...packs.map(p=>({...p, pack:true}))
  ].sort((a,b)=>Math.hypot(b.x-player.x,b.y-player.y)-Math.hypot(a.x-player.x,a.y-player.y));

  for (const s of all) {
    const dx = s.x - player.x, dy = s.y - player.y;
    const dist = Math.hypot(dx, dy);
    if (dist > MAX_DEPTH) continue;
    let angle = Math.atan2(dy, dx) - player.angle;
    if (angle > Math.PI) angle -= 2*Math.PI;
    if (angle < -Math.PI) angle += 2*Math.PI;
    if (Math.abs(angle) > FOV/2+0.1) continue;
    const cd = dist * Math.cos(angle);
    const size = (TILE * (s.enemy ? 800 : 600)) / cd;
    const sx = canvas.width/2 + Math.tan(angle) * canvas.width/(2*Math.tan(FOV/2));
    for (let x = sx - size/2; x < sx + size/2; x++) {
      if (x<0||x>=canvas.width||z[Math.floor(x/2)]<cd) continue;
      ctx.fillStyle = s.pack ? "lime" : (s.fast?"blue":"red");
      ctx.fillRect(x, mid - size/2, 1, size);
    }
  }
}

function renderHUD() {
  ctx.font = "16px monospace";
  ctx.fillStyle = "#000"; ctx.fillRect(20,20,200,25);
  const hpColor = player.hp > 50 ? "lime" : player.hp > 25 ? "yellow" : "red";
  ctx.fillStyle = hpColor;
  ctx.fillRect(20,20,200*(player.hp/PLAYER_HP),25);
  ctx.strokeStyle = "#fff"; ctx.strokeRect(20,20,200,25);
  ctx.fillStyle = "#fff";
  ctx.fillText(`HP: ${player.hp}`, 30, 60);
  ctx.fillText(`SCORE: ${player.score}`, 30, 80);

  // Crosshair
  ctx.strokeStyle = shootTimer > 0 ? "red" : "white";
  const c = canvas.width/2, m = canvas.height/2;
  ctx.beginPath();
  ctx.moveTo(c-10,m); ctx.lineTo(c-3,m);
  ctx.moveTo(c+3,m); ctx.lineTo(c+10,m);
  ctx.moveTo(c,m-10); ctx.lineTo(c,m-3);
  ctx.moveTo(c,m+3); ctx.lineTo(c,m+10);
  ctx.stroke();
}

function renderGun() {
  const w = 150, h = 100;
  const y = canvas.height - h - 10 + Math.sin(player.bob)*10;
  ctx.fillStyle = "#666"; ctx.fillRect(canvas.width/2 - w/2, y, w, h);
  ctx.fillStyle = "#333"; ctx.fillRect(canvas.width/2 - w/2 + w*0.1, y + h*0.1, w*0.8, h*0.2);
  const last = bullets[bullets.length-1];
  if (last && last.flash > 0) {
    ctx.fillStyle = "yellow";
    ctx.globalAlpha = last.flash / 5;
    ctx.fillRect(canvas.width/2 + w/2 - 20, y+5, 20, 20);
    ctx.globalAlpha = 1;
  }
}

function renderGameOver() {
  ctx.fillStyle = "rgba(0,0,0,0.7)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = "red"; ctx.font = "60px sans-serif";
  ctx.textAlign = "center";
  ctx.fillText("YOU DIED", canvas.width/2, canvas.height/2 - 40);
  ctx.font = "30px sans-serif";
  ctx.fillStyle = "white";
  ctx.fillText(`Final Score: ${player.score}`, canvas.width/2, canvas.height/2 + 30);
  ctx.font = "16px sans-serif";
  ctx.fillText("Click to restart", canvas.width/2, canvas.height/2 + 70);
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  render3D();
  renderGun();
  renderHUD();
  if (gameOver) renderGameOver();
}

// --- Main Loop ---
(function loop() {
  update();
  render();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
